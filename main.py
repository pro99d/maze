import arcadeimport randomimport jsonimport timeimport mathfrom mazegenerator import MazeGeneratorfrom hud import HUDclass MazeGame(arcade.Window):    def __init__(self, width, height, tile_size, wall_thickness, colors, title, fov, turn_sensitivity, wall_height, ray_step):        super().__init__(width, height, title, fullscreen=True)        self.set_fullscreen(True)        arcade.set_background_color(colors["background"])        self.tile_size = tile_size        self.colors = colors        self.generator = MazeGenerator(width // tile_size, height // tile_size)        self.maze = self.generator.generate_maze()        try:            with open("maze.json", "r") as file:                self.maze = json.load(file)        except FileNotFoundError:            print("Ошибка: файл maze.json не найден.")            return        self.hud = HUD(self.maze, self.tile_size)        self.player_x, self.player_y = self.spawn_player()        self.player_angle = 0        self.score = 0        self.start_time = time.time()        self.keys_pressed = set()        self.fov = fov        self.turn_sensitivity = turn_sensitivity        self.wall_height = wall_height        self.ray_step = ray_step        self.precomputed_cos = [math.cos(math.radians(a)) for a in range(360)]        self.precomputed_sin = [math.sin(math.radians(a)) for a in range(360)]    def spawn_player(self):        for y in range(len(self.maze)):            for x in range(len(self.maze[y])):                if self.maze[y][x] == 'S':                    return x + 0.5, y + 0.5        self.maze = self.generator.generate_maze()        return self.spawn_player()    def on_draw(self):        arcade.start_render()        self.raycast()        self.hud.draw(self.player_x, self.player_y, self.player_angle, self.colors, self.score, True if self.check_collision(self.player_x, self.player_y) == 'finish' else False, True if arcade.key.M in self.keys_pressed else False)    def check_block(self, x, y):        return self.maze[int(y)][int(x)]    def raycast(self):        half_fov = self.fov / 2        for x in range(0, self.width, 2):  # Увеличен шаг для уменьшения количества лучей            ray_angle = (self.player_angle - half_fov) + (x / self.width) * self.fov            ray_angle_rad = ray_angle % 360            ray_x, ray_y = self.player_x, self.player_y            cos_angle = self.precomputed_cos[int(ray_angle_rad)]            sin_angle = self.precomputed_sin[int(ray_angle_rad)]            while True:                ray_x += self.ray_step * cos_angle                ray_y += self.ray_step * sin_angle                if ray_x < 0 or ray_x >= len(self.maze[0]) or ray_y < 0 or ray_y >= len(self.maze):                    break                if self.check_block(ray_x, ray_y) == '#':                    color = self.colors['wall']                    break                elif self.check_block(ray_x, ray_y) == 'F':                    color = self.colors['finish']                    break                elif self.check_block(ray_x, ray_y) == "S":                    color = self.colors['start']                    break            distance = ((ray_x - self.player_x) ** 2 + (ray_y - self.player_y) ** 2) ** 0.5            height = self.wall_height/distance            intensity = max(0, 255 - min(255, distance * 50))            color = (intensity * color[0] // 255,                     intensity * color[1] // 255,                     intensity * color[2] // 255)            arcade.draw_rectangle_filled(self.width - x, self.height / 2, 2, height, color)    def calculate_score(self):        elapsed_time = time.time() - self.start_time        max_score = (5 * (len(self.maze[0]) + len(self.maze)) / 2)        self.score = max(0, round(max_score / elapsed_time))        self.hud.draw_score(self.score)    def on_key_press(self, key, modifiers):        self.keys_pressed.add(key)    def on_key_release(self, key, modifiers):        self.keys_pressed.discard(key)    def update(self, delta_time):        next_x = self.player_x        next_y = self.player_y        if arcade.key.R in self.keys_pressed:            arcade.close_window()            main()        if arcade.key.Q in self.keys_pressed:            arcade.close_window()        if arcade.key.W in self.keys_pressed:            next_y += 0.5 * self.precomputed_sin[int(self.player_angle % 360)]*delta_time            next_x += 0.5 * self.precomputed_cos[int(self.player_angle % 360)]*delta_time        if arcade.key.S in self.keys_pressed:            next_y -= 0.5 * self.precomputed_sin[int(self.player_angle % 360)]*delta_time            next_x -= 0.5 * self.precomputed_cos[int(self.player_angle % 360)]*delta_time        if arcade.key.I in self.keys_pressed:            self.ray_step += 0.01        elif arcade.key.K in self.keys_pressed:            self.ray_step -= 0.01        if arcade.key.O in self.keys_pressed:            self.fov += 10        if arcade.key.L in self.keys_pressed:            self.fov -= 10        if self.check_collision(next_x, next_y):            self.player_x = next_x            self.player_y = next_y        if self.check_collision(next_x, next_y) == "finish":            self.calculate_score()        if arcade.key.A in self.keys_pressed:            self.player_angle += self.turn_sensitivity        if arcade.key.D in self.keys_pressed:            self.player_angle -= self.turn_sensitivity        if arcade.key.Q in self.keys_pressed:            arcade.close_window()    def check_collision(self, x, y):        if x < 0 or x >= len(self.maze[0]) or y < 0 or y >= len(self.maze):            return False        return self.maze[int(y)][int(x)] != '#' if self.maze[int(y)][int(x)] !="F" else 'finish'def load_config(filename='config.json'):    try:        with open(filename, 'r') as f:            config = json.load(f)        return config    except FileNotFoundError:        print("Ошибка: файл config.json не найден.")        return Nonedef main():    config = load_config()    if config:        game = MazeGame(            config['resolution_width'],            config['resolution_height'],            config['tile_size'],            config['wall_thickness'],            config['colors'],            "Maze Generator",            config['fov'],            config['turn_sensitivity'],            config['wall_height'],            config['ray_step']        )        arcade.run()if __name__ == "__main__":    main()